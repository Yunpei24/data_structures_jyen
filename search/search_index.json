{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf31 Welcome to JYEN Data Structures","text":"<p>\ud83c\udf93 This project is a comprehensive and educational resource showcasing classic data structures implemented in Python. Whether you're a student, a developer, or a curious learner, this guide will help you master core data structures with clear examples and hands-on notebooks.</p>"},{"location":"#what-youll-find","title":"\ud83d\udcda What You\u2019ll Find","text":"<p>Dive into well-organized sections, each dedicated to a fundamental data structure:</p> <ul> <li>\u2705 Arrays \u2013 Static and dynamic storage structures.</li> <li>\u2705 Stacks \u2013 Last-In, First-Out (LIFO) operations.</li> <li>\u2705 Queues \u2013 First-In, First-Out (FIFO) workflows.</li> <li>\u2705 Linked Lists \u2013 Sequential nodes linked dynamically.</li> <li>\u2705 Trees \u2013 Hierarchical structures for sorted data.</li> <li>\u2705 Graphs \u2013 Representing relationships between elements.</li> </ul> <p>Each section includes:</p> <ul> <li>\u2728 Concept explanations</li> <li>\ud83d\udcbb Python code examples</li> <li>\ud83d\udcd3 Interactive Jupyter Notebooks (coming soon)</li> </ul>"},{"location":"#get-started","title":"\ud83d\ude80 Get Started","text":"<p>Click on a topic in the navigation bar to begin exploring!</p> <p>If you're viewing this on GitHub, you can also explore the full source code and notebooks here: \ud83d\udd17 GitHub Repository</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>This project is open-source and welcomes contributions. Feel free to open issues, suggest improvements, or add your own implementations!</p>"},{"location":"#author","title":"\ud83d\udc68\u200d\ud83d\udcbb Author","text":"<p>Made with \u2764\ufe0f by Joshua Juste Emmanuel Yun Pei NIKIEMA @yunpei24</p> <p>\"Mastering data structures is the first step toward becoming a great software engineer.\" </p>"},{"location":"array/","title":"Arrays","text":"<p>Arrays are fundamental data structures used to store elements in contiguous memory locations.</p>"},{"location":"array/#characteristics","title":"Characteristics","text":"<ul> <li>Fast index-based access (constant time)</li> <li>Static size (fixed at creation time)</li> <li>Elements must be of the same type (in many languages)</li> <li>Memory efficient for random access operations</li> </ul>"},{"location":"array/#common-operations","title":"Common Operations","text":"Operation Description Time Complexity Access Retrieve element at index O(1) Insert Add element at specific position O(n) Delete Remove element at specific position O(n) Search Find element by value O(n) Update Change value at specified index O(1)"},{"location":"array/#visual-representation","title":"Visual Representation","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502 10 \u2502 20 \u2502 30 \u2502 40 \u2502 50 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n  0    1    2    3    4    \u2190 Indices\n</code></pre>"},{"location":"array/#implementation","title":"Implementation","text":"<p>Python's <code>Array</code> class provides an implementation with fixed capacity and common array operations.</p> <pre><code># Example usage:\narr = Array(5)  # Create array with capacity 5\narr.insert_at(0, 10)\narr.insert_at(1, 20)\nelement = arr.get(0)  # Returns 10\n</code></pre>"},{"location":"array/#applications","title":"Applications","text":"<ul> <li>Storing and accessing sequential data</li> <li>Matrix operations</li> <li>Lookup tables and hash tables</li> <li>Image processing</li> <li>Buffer implementations</li> </ul>"},{"location":"array/#example-notebook","title":"Example Notebook","text":"<p>\ud83d\udc49 See Array Example Notebook</p>"},{"location":"linked_list/","title":"Linked List","text":"<p>A Linked List is a linear data structure where elements are stored in separate memory locations and connected through references (pointers).</p>"},{"location":"linked_list/#features","title":"Features","text":"<ul> <li>Dynamic Size: Unlike arrays, linked lists can grow or shrink at runtime</li> <li>Efficient Insertions/Deletions: Adding or removing elements doesn't require shifting other elements</li> <li>No Random Access: Elements must be accessed sequentially from the first node</li> <li>Extra Memory: Requires additional memory for storing references/pointers</li> </ul>"},{"location":"linked_list/#types-of-linked-lists","title":"Types of Linked Lists","text":"<ol> <li>Singly Linked List: Each node points to the next node</li> <li>Doubly Linked List: Each node points to both next and previous nodes</li> <li>Circular Linked List: Last node points back to the first node</li> </ol>"},{"location":"linked_list/#visual-representation","title":"Visual Representation","text":"<pre><code>Singly Linked List:\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2502  \u25cf\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25b6 B   \u2502  \u25cf\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25b6 C   \u2502 null\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n data  next       data  next       data  next\n</code></pre>"},{"location":"linked_list/#implementation","title":"Implementation","text":"<pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n</code></pre>"},{"location":"linked_list/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity Access O(n) Search O(n) Insertion O(1)* Deletion O(1)* <p>* When position is known, otherwise O(n) to find the position first</p>"},{"location":"linked_list/#example","title":"Example","text":"<p>Check the Linked List Notebook for implementation details.</p> <p>Note: Unlike arrays, linked lists do not have fast index-based access or static size. They excel at dynamic memory allocation and efficient insertions/deletions.</p>"},{"location":"queue/","title":"Queues","text":"<p>A queue is a linear data structure that follows the FIFO (First In First Out) principle.</p>"},{"location":"queue/#characteristics","title":"Characteristics","text":"<ul> <li>Elements are added from the rear and removed from the front</li> <li>Used in scheduling, buffering, and task queues</li> <li>Maintains insertion order for processing</li> </ul>"},{"location":"queue/#common-operations","title":"Common Operations","text":"Operation Description Time Complexity <code>enqueue()</code> Add an item to the rear of the queue O(1) <code>dequeue()</code> Remove and return the front item O(1) <code>peek()</code> View the front item without removing it O(1) <code>is_empty()</code> Check if the queue is empty O(1)"},{"location":"queue/#visual-representation","title":"Visual Representation","text":"<pre><code>       enqueue                dequeue\n          \u2193                      \u2191\n        \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\nRear \u2192 \u2502 40 \u2502 30 \u2502 20 \u2502 10 \u2502  5 \u2502 \u2190 Front\n        \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"queue/#implementation","title":"Implementation","text":"<p>Python's <code>Queue</code> class uses a list-based implementation with operations that maintain FIFO behavior.</p> <pre><code># Example usage:\nqueue = Queue()\nqueue.enqueue(5)\nqueue.enqueue(10)\nelement = queue.dequeue()  # Returns 5\n</code></pre>"},{"location":"queue/#applications","title":"Applications","text":"<ul> <li>Task scheduling in operating systems</li> <li>Print job queues</li> <li>BFS (Breadth-First Search) algorithm</li> <li>Request handling in web servers</li> <li>Call center systems</li> </ul>"},{"location":"queue/#example-notebook","title":"Example Notebook","text":"<p>\ud83d\udc49 See Queue Example Notebook</p>"},{"location":"stack/","title":"Stacks","text":"<p>A stack is a linear data structure that follows the LIFO (Last In First Out) principle.</p>"},{"location":"stack/#characteristics","title":"Characteristics","text":"<ul> <li>Elements are added (pushed) and removed (popped) from the top</li> <li>Useful for undo operations, expression evaluation, and more</li> <li>Access is restricted to the top element only</li> </ul>"},{"location":"stack/#common-operations","title":"Common Operations","text":"Operation Description Time Complexity <code>push()</code> Add an item to the top of stack O(1) <code>pop()</code> Remove and return the top item O(1) <code>peek()</code> View the top item without removing it O(1) <code>is_empty()</code> Check if the stack is empty O(1)"},{"location":"stack/#visual-representation","title":"Visual Representation","text":"<pre><code>     \u250c\u2500\u2500\u2500\u2500\u2510\n     \u2502 40 \u2502 \u2190 Top (Last In)\n     \u251c\u2500\u2500\u2500\u2500\u2524\n     \u2502 30 \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2524\n     \u2502 20 \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2524\n     \u2502 10 \u2502\n     \u251c\u2500\u2500\u2500\u2500\u2524\n     \u2502  5 \u2502 \u2190 Bottom (First In)\n     \u2514\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"stack/#implementation","title":"Implementation","text":"<p>Python's <code>Stack</code> class provides methods for standard stack operations with a private list for storage.</p> <pre><code># Example usage:\nstack = Stack()\nstack.push(5)\nstack.push(10)\nelement = stack.pop()  # Returns 10\n</code></pre>"},{"location":"stack/#applications","title":"Applications","text":"<ul> <li>Function call management (call stack)</li> <li>Expression evaluation and syntax parsing</li> <li>Undo mechanisms in text editors</li> <li>Browser history tracking</li> <li>Backtracking algorithms</li> </ul>"},{"location":"stack/#example-notebook","title":"Example Notebook","text":"<p>\ud83d\udc49 See Stack Example Notebook</p>"},{"location":"tree/","title":"Trees","text":"<p>A tree is a hierarchical data structure with nodes connected in parent-child relationships.</p>"},{"location":"tree/#characteristics","title":"Characteristics","text":"<ul> <li>The topmost node is called the root</li> <li>Each node can have multiple children</li> <li>Used in file systems, databases, compilers, etc.</li> <li>No cycles (unlike graphs)</li> <li>Every node (except root) has exactly one parent</li> </ul>"},{"location":"tree/#types","title":"Types","text":"Tree Type Description Binary Tree Each node has at most two children Binary Search Tree (BST) Left child &lt; parent &lt; right child AVL Tree Self-balancing BST Red-Black Tree Self-balancing BST with color properties B-Tree Self-balancing tree optimized for storage systems Heap Complete binary tree with heap property"},{"location":"tree/#visual-representation","title":"Visual Representation","text":"<pre><code>        \u250c\u2500\u2500\u2500\u2510\n        \u2502 8 \u2502        \u2190 Root\n        \u2514\u2500\u252c\u2500\u2518\n     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n   \u250c\u2500\u2534\u2500\u2510     \u250c\u2500\u2534\u2500\u2510\n   \u2502 3 \u2502     \u2502 10\u2502\n   \u2514\u2500\u252c\u2500\u2518     \u2514\u2500\u252c\u2500\u2518\n  \u250c\u2500\u2500\u2534\u2500\u2500\u2510      \u2514\u2500\u2500\u2510\n\u250c\u2500\u2534\u2500\u2510 \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2534\u2500\u2510\n\u2502 1 \u2502 \u2502 6 \u2502    \u2502 14\u2502\n\u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tree/#common-operations","title":"Common Operations","text":"Operation Description Time Complexity (BST) <code>insert()</code> Add a new node O(log n) average, O(n) worst <code>delete()</code> Remove a node O(log n) average, O(n) worst <code>search()</code> Find a node O(log n) average, O(n) worst <code>traverse()</code> Visit all nodes O(n)"},{"location":"tree/#traversal-methods","title":"Traversal Methods","text":"<ul> <li>Preorder: Root \u2192 Left \u2192 Right</li> <li>Inorder: Left \u2192 Root \u2192 Right (gives sorted output for BST)</li> <li>Postorder: Left \u2192 Right \u2192 Root</li> </ul>"},{"location":"tree/#applications","title":"Applications","text":"<ul> <li>File systems organization</li> <li>Database indexing</li> <li>Decision trees in machine learning</li> <li>Expression evaluation</li> <li>Network routing algorithms</li> </ul>"},{"location":"tree/#example-notebook","title":"Example Notebook","text":"<p>\ud83d\udc49 See Tree Example Notebook</p>"}]}